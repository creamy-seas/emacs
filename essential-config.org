#+TITLE: First file to load
#+STARTUP: overview
#+PROPERTY: header-args :tangle yes

* Automatic file reload
Any changes of a file, will be automatically reloaded
#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode 1)
(setq load-prefer-newer t)
 #+END_SRC
* Yes or no
#+begin_src emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+end_src

* PACKAGE =ido= mode
- Vertical buffer do display choices (full package is the search engine)
- Use =ido-completing-read= to display the selection
#+begin_src emacs-lisp
(ido-vertical-mode 1)
(setq ido-vertical-define-keys 'C-n-and-C-p-only)
#+end_src

* Keymap: MacOs
Mapping of mac right keyboard to meta dgds

#+BEGIN_SRC emacs-lisp
(setq ns-right-option-modifier 'meta
      mac-right-option-modifier 'meta)
#+END_SRC

* Keymap: Russian
#+BEGIN_SRC emacs-lisp
  (use-package! reverse-im
    :config
    (reverse-im-activate "russian-computer"))
 #+END_SRC
* Keymap: my subpsace
Access to my custom keymap space on =C-z= or =C-\=
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/keymap)
  (global-set-key (kbd "C-z") 'my/keymap)
  (global-set-key (kbd "C-\\") 'my/keymap)
  (add-hook 'org-mode-hook (lambda ()
                              (keymap-set org-mode-map "C-#" nil)))
  (global-set-key (kbd "C-#") 'my/keymap)
 #+END_SRC
* Keymap: symbols
#+BEGIN_SRC emacs-lisp
  (define-key key-translation-map (kbd "C-x 8 h") (kbd "å")) ; naughty
  (define-key key-translation-map (kbd "C-x 8 C") (kbd "â˜­")) ; erm, kinda naughty
  (define-key key-translation-map (kbd "C-x 8 e") (kbd "ðŸ˜"))
  (define-key key-translation-map (kbd "C-x 8 p") (kbd "Ï€"))
  (define-key key-translation-map (kbd "C-x 8 s") (kbd "ðŸ¦‘"))
  (define-key key-translation-map (kbd "C-x 8 o") (kbd "ðŸ™"))
  (define-key key-translation-map (kbd "C-x 8 w") (kbd "ðŸ³"))
  (define-key key-translation-map (kbd "C-x 8 W") (kbd "ðŸ‹"))
  (define-key key-translation-map (kbd "C-x 8 O") (kbd "Î©"))
  (define-key key-translation-map (kbd "C-x 8 #") (kbd "Â£"))
  (define-key key-translation-map (kbd "C-x 8 t") (kbd "âœ”"))
  (define-key key-translation-map (kbd "C-x 8 c") (kbd "âœ˜"))
  (define-key key-translation-map (kbd "C-x 8 b") (kbd "â¦¿"))
  (define-key key-translation-map (kbd "C-x 8 2") (kbd "Â²"))
  (define-key key-translation-map (kbd "C-x 8 l") (kbd "Î»"))
  (global-set-key (kbd "C-c i") (function info-other-window))
 #+END_SRC

* Identification
- GPG configuration and email
#+BEGIN_SRC emacs-lisp
(setq user-full-name "Ilya Antonov")
(setq user-mail-address "ilya.antonov24@ntlworld.com")
 #+END_SRC

* Major Functions
** Browsing configuration files =C-c f i=
#+begin_src emacs-lisp
(defun my/config-file-open ()
  "Browser config files in `doom-user-dir'."
  (interactive)
  (let ((file-list
         ;; Remove files that are not org files and not one of the default doom files
         (cl-remove-if-not
          (lambda (x)
            (or (equal "org" (file-name-extension x))
                (string-match "^\\(config\\|custom\\|packages\\|init\\).el$" x)))
          (directory-files doom-user-dir))))
    (find-file (concat doom-user-dir (ido-completing-read "Config file: " file-list)))))

(global-set-key (kbd "C-c f i") (function my/config-file-open))
#+end_src
** Browser private config =C-c f m=
#+begin_src emacs-lisp
(defun my/private-config-open ()
  "Open an interactively chosen file in the ./config directory."
  (interactive)
  (let* ((config-dir (expand-file-name "~/.config"))
         (chosen-file (completing-read "Choose a file: " (directory-files config-dir t))))
      (if (file-exists-p chosen-file)
          (find-file chosen-file)
        (message "File does not exist: %s" chosen-file))))

(global-set-key (kbd "C-c f q") (function my/private-config-open))
#+end_src
** Compiling of literate configuration
Whenever an org file specifying configuration is saved
1. Tangle it (extract out all of the Emacs-lisp code blocks)
2. Compile it (=.el= -> =.elc=)
3. Reload doom

#+BEGIN_SRC emacs-lisp
(defun my/config-file-tangle ()
  "Tangle if file is a configuration file"
  (if (and
       (equal (file-name-extension (buffer-file-name)) "org")
       (not (equal (file-name-base (buffer-file-name)) "cheatsheet"))
       (equal (file-name-directory (buffer-file-name)) (expand-file-name doom-user-dir)))
      ;; Tangle the file and bytecompile it
      (let ((el-file-name (replace-regexp-in-string "\\.org" ".el" buffer-file-name)))
        (org-babel-tangle-file buffer-file-name el-file-name "emacs-lisp")
        (byte-compile-file el-file-name)
        ;;(doom/reload)
        (message (concat "Ûž Compiled and loaded " el-file-name)))))
(add-hook 'after-save-hook 'my/config-file-tangle)
 #+END_SRC
** Kill current buffer
Always kill the current buffer - for some reason it is not the default

#+BEGIN_SRC emacs-lisp
(defun my/kill-curr-buffer ()
  (interactive)
  (kill-buffer (current-buffer)))
(global-set-key (kbd "C-x k") 'my/kill-curr-buffer)
#+END_SRC

* Minor Functions
** =my/get-frame-name=
#+begin_src emacs-lisp
(defun my/get-frame-name (&optional frame)
  "Return the string that names FRAME (a frame).  Default is selected frame."
  (unless frame
                                        ; Default to current frame
    (setq frame (selected-frame)))
  (if (framep frame)
                                        ; If argument is grame, unpack the name parameter
      (cdr (assq 'name (frame-parameters frame)))
    (error "Function `get-frame-name': Argument not a frame: `%s'" frame)))
#+end_src
** =my/find-frame=
#+begin_src emacs-lisp
(defun my/find-frame (frame)
  "Return a frame, if any, named FRAME (a frame or a string).
If none, return nil.
If FRAME is a frame, it is returned."
  (cond ((framep frame) frame) ; Return the frame straigh away
        ((stringp frame) ; If string is supplied iterate through until matching frame is found
         (catch 'get-a-frame-found
           (dolist (fr (frame-list))
             (when (string= frame (my/get-frame-name fr))
               (throw 'get-a-frame-found fr)))
           ;; No frame is found
           nil))
        (t (error
            "Function `get-frame-name': Arg neither a string nor a frame: `%s'"
            frame))))
#+end_src
** =my/gpg-load=
#+begin_src emacs-lisp
(defun my/gpg-load ()
  "Forces user to enter a gpg password if it expired -
  run before commands where gpg decryption is required"
  (epa-decrypt-file
   (concat doom-user-dir "my-files/gpg/load_password_dummy_file.gpg") "/dev/null"))
#+end_src
** =my/read-string-from-file=
#+BEGIN_SRC emacs-lisp
  (defun my/read-string-from-file (filePath)
    "Return filePath's file content."
    (with-temp-buffer
      (insert-file-contents filePath)
      (buffer-string)))
 #+END_SRC
** =my/copy-line=
#+BEGIN_SRC emacs-lisp
  (defun my/copy-line ()
    "Copies the current line of the cursor
       Returns the current line as a string"
    (interactive)
    (buffer-substring (line-beginning-position) (line-end-position)))
 #+END_SRC
** DOWN =my/copy-line-save-position=
#+BEGIN_SRC emacs-lisp
  ;; (defun my/copy-line-save-position ()
  ;;   (interactive)
  ;;   (save-excursion ;;save the cursor position
  ;;     (kill-new            ;;kill the following
  ;;      (buffer-substring ;;from begginin of line to end of line
  ;;       (point-at-bol)
  ;;       (point-at-eol)))))
  ;; (global-set-key (kbd "C-c w l") (function my/copy-line-save-position))
#+END_SRC
** =my/drop-duplicates-in-list=
#+BEGIN_SRC emacs-lisp
  (defun my/drop-duplicates-in-list (list)
    (let ((new-list nil))
      (while list
        (when (and (car list) (not (member (car list) new-list)))
          (setq new-list (cons (car list) new-list)))
        (setq list (cdr list)))
      (nreverse new-list)))
 #+END_SRC
** =my/strings/recursive-count=                                      :regex:
#+BEGIN_SRC emacs-lisp
  (defun my/strings/recursive-count (regex string start)
    "Count number of matches in string eggining from 'start' offset"
    (if (string-match regex string start)
        (+ 1 (my/strings/recursive-count regex string (match-end 0)))
      0))
 #+END_SRC
** =my/extract-string=
#+BEGIN_SRC emacs-lisp
  (defun my/extract-string (regexp index string)
    "Extract a particular part of a regexp from the chosen string
    -------------------------------------------------------------------
    regexp     regular expression with individual arguments in \\(\\)
    index         index match to extract
    string        string to extract from
    "
    (string-match regexp string)
    (match-string index string))
 #+END_SRC
** =my/figlet=
#+BEGIN_SRC emacs-lisp
  (defun my/figlet (string-to-convert)
    "Converts 'string-to-convert' to ascii art and inserts it into buffer

      string-to-convert:	string to turn to art
      "
    (interactive "sString to make into art: ")
    (let* ((ascii-art (shell-command-to-string (concat "figlet -k" " " string-to-convert))))
      (setq ascii-art (replace-regexp-in-string "^"
                                                comment-start
                                                ascii-art))
      (insert ascii-art)
      ))
 #+END_SRC
** =my/file-name-from-line=
#+BEGIN_SRC emacs-lisp
  (defun my/file-name-from-line (prefix suffix)
    "Copies the current line and elinates all spaces"
    (interactive)
    (let* (
           (file-name (my/copy-line))
           (file-name (replace-regexp-in-string "^\s*" "" file-name))
           (file-name (downcase file-name))
           (file-name (replace-regexp-in-string " " "_" file-name))
           (file-name (concat prefix file-name suffix)))
      (message file-name)))
 #+END_SRC
** =my/generate-filename-from-line=
#+BEGIN_SRC emacs-lisp
  (defun my/generate-filename-from-line ()
    "Reads in the current line and generates a valid filename with an underscore"
    (let* (;reads in current line
           (file-name (my/copy-line)))
      ;; Trim leading whitespaces -> downcase -> replace spaces with underscore
      (replace-regexp-in-string " " "_" (downcase (replace-regexp-in-string "^\s*" "" file-name)))))
 #+END_SRC
** =my/rename-file-and-buffer=
#+BEGIN_SRC emacs-lisp
  (defun my/rename-file-and-buffer ()
    "Rename the current buffer and file it is visiting."
    (interactive)
    (let ((filename (buffer-file-name)))
      (if (not (and filename (file-exists-p filename)))
          (message "Buffer is not visiting a file!")
        (let ((new-name (read-file-name "New name: " filename)))
          (cond
           ((vc-backend filename) (vc-rename-file filename new-name))
           (t
            (rename-file filename new-name t)
            (set-visited-file-name new-name t t)))))))
 #+END_SRC
** =my/write-list-into-current-buffer=
#+BEGIN_SRC emacs-lisp
  (defun my/write-list-into-current-buffer (list-to-write)
    "Inserts elements of a simple list 1-by-1 into the current file"
    (while list-to-write
      (insert (format "%s\n" (car list-to-write)))
      (setq list-to-write (cdr list-to-write))))
 #+END_SRC

** =my/say-region=
#+begin_src emacs-lisp
(defun my/speak-region (start end)
 (interactive "r")
 (shell-command-on-region start end "say $(cat)")
)
(define-key my/keymap (kbd "S") 'my/speak-region)
#+end_src
