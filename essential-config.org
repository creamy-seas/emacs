#+TITLE: First file to load
#+STARTUP: overview
#+PROPERTY: header-args :tangle yes

* Yes or no
#+begin_src emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+end_src

* =IDO= mode
#+begin_src emacs-lisp
;;(ido-vertical-mode 1)
;;(setq ido-vertical-define-keys 'C-n-and-C-p-only)
#+end_src

* Mac keymap
Mapping of mac right keyboard to meta dgds

#+BEGIN_SRC emacs-lisp
(setq ns-right-option-modifier 'meta
      mac-right-option-modifier 'meta)
#+END_SRC

* Kill current buffer
Always kill the current buffer - for some reason it is not the default

#+BEGIN_SRC emacs-lisp
(defun my/kill-curr-buffer ()
  (interactive)
  (kill-buffer (current-buffer)))
(global-set-key (kbd "C-x k") 'my/kill-curr-buffer)
#+END_SRC

* Line numbers
#+BEGIN_SRC emacs-lisp
;; This determines the style of line numbers in effect. If set to `nil', line
;; numbers are disabled. For relative line numbers, set this to `relative'.
;;(setq display-line-numbers-type t)
;;(setq display-line-numbers-type nil)
#+END_SRC

* Identification
- GPG configuration and email
#+BEGIN_SRC emacs-lisp
;;(setq user-full-name "Ilya Antonov")
;;(setq user-mail-address "ilya.antonov24@ntlworld.com")
 #+END_SRC

* Compiling of literate configuration
Whenever an org file specifying configuration is saved
1. Tangle it (extract out all of the Emacs-lisp code blocks)
2. Compile it (=.el= -> =.elc=)
3. Reload doom

#+BEGIN_SRC emacs-lisp
(defun my/config-file-tangle ()
  "Tangle if file is a configuration file"
  (if (and
       (equal (file-name-extension (buffer-file-name)) "org")
       (not (equal (file-name-base (buffer-file-name)) "cheatsheet"))
       (equal (file-name-directory (buffer-file-name)) (expand-file-name doom-user-dir)))
      ;; Tangle the file and bytecompile it
      (let ((el-file-name (replace-regexp-in-string "\\.org" ".el" buffer-file-name)))
        (org-babel-tangle-file buffer-file-name el-file-name "emacs-lisp")
        (byte-compile-file el-file-name)
        ;;(doom/reload)
        (message (concat "۞ Compiled and loaded " el-file-name)))))
(add-hook 'after-save-hook 'my/config-file-tangle)
 #+END_SRC
* My keymap
Access to my custom keymap space on =C-z= or =C-\=
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/keymap)
  (global-set-key (kbd "C-z") 'my/keymap)
  (global-set-key (kbd "C-\\") 'my/keymap)
 #+END_SRC

* Saving hooks
#+BEGIN_SRC emacs-lisp
;;(add-hook 'before-save-hook #'whitespace-cleanup)
;;(add-hook 'before-save-hook 'delete-trailing-whitespace)
;;(setq require-final-newline    t)
;;(setq next-line-add-newlines nil)
 #+END_SRC

* Overwrite selected text when typing
#+BEGIN_SRC emacs-lisp
(delete-selection-mode t)
 #+END_SRC

* PACKAGE Hungry delete
Hungry delete deletes all white space between cursor and the next character
#+BEGIN_SRC emacs-lisp
  (use-package! hungry-delete
    :config
    (global-hungry-delete-mode))
#+END_SRC

* PACKAGE Searching with Swiper =C-s=

#+BEGIN_SRC emacs-lisp
;; (global-set-key (kbd "C-s") (function counsel-grep-or-swiper))
;; (setq counsel-grep-base-command
;;       "rg -i -M 120 --no-heading --line-number --color never %s %s")

;; (setq counsel-grep-use-swiper-p
;;       ;; When this functions returns non-nil, call 'swiper', else 'counsel-grep-base-command'
;;       (lambda ()
;;         (or
;;          ;; If buffer is small enough
;;          (<= (buffer-size) (/ counsel-grep-swiper-limit (if (eq major-mode 'org-mode) 4 1)))
;;          (string-match "\\.gpg$" (file-name-nondirectory (buffer-file-name))))))




#+END_SRC

* Browsing configuration files =C-c f i=

#+begin_src emacs-lisp
(defun my/config-file-open ()
  "Browser config files in `doom-user-dir'."
  (interactive)
  (let ((file-list
         ;; Remove files that are not org files and not one of the default doom files
         (cl-remove-if-not
          (lambda (x)
            (or (equal "org" (file-name-extension x))
                (string-match "^\\(config\\|custom\\|packages\\|init\\).el$" x)))
          (directory-files doom-user-dir))))
    (find-file (concat doom-user-dir (ido-completing-read "Config file: " file-list)))))

(global-set-key (kbd "C-c f i") (function my/config-file-open))
#+end_src

* Auto yasnippets

Quickly create disposable yasnippets with =~=
#+BEGIN_SRC emacs-lisp
  (use-package! auto-yasnippet
    :config
    (define-key my/keymap (kbd "s") (function aya-create))
    (define-key my/keymap (kbd "y") (function aya-expand)))
 #+END_SRC
* Company autocompletion
- Name stands for compLETEanything
- =company-backends=: lists backends that are used to return candidates

#+BEGIN_SRC emacs-lisp
(after! company
  (setq company-tooltip-align-annotations t)
                                        ;set time before company popup shows up
  (setq company-idle-delay 0.2)
                                        ;;when autocompletion kicks in
  (setq company-minimum-prefix-length 4))
 #+END_SRC

* Undo Tree     =M-/=
Spawns a tree of all the undos that you have ever made
#+BEGIN_SRC emacs-lisp
(use-package! undo-tree
  :config
  (global-undo-tree-mode)
  (setq undo-tree-visualizer-timestamps t)
  (setq undo-tree-visualizer-diff t)
  (global-set-key (kbd "M-/") 'undo-tree-visualize)
)
#+END_SRC

* Tabs
Tabs are bloat. Read about them [[http://www.xemacs.org/Links/tutorials_1.html][here]]
** Change display of tabs
#+BEGIN_SRC emacs-lisp
  (setq-default tab-width 4)
 #+END_SRC
** Prevent using tabs for indent
#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
 #+END_SRC
* iedit =C-:=
Mark and edit all copies of the marked region simultaneously.
#+BEGIN_SRC emacs-lisp
(use-package! iedit
  :bind ("C-:" . iedit-mode))
 #+END_SRC
* Automatic file reload
Any changes of a file, will be automatically reloaded
#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode 1)
(setq load-prefer-newer t)
 #+END_SRC
* Russian keymap
#+BEGIN_SRC emacs-lisp
  (use-package! reverse-im
    :config
    (reverse-im-activate "russian-computer"))
 #+END_SRC
* Symbols mapping
#+BEGIN_SRC emacs-lisp
  (define-key key-translation-map (kbd "C-x 8 h") (kbd "卍")) ; naughty
  (define-key key-translation-map (kbd "C-x 8 C") (kbd "☭")) ; erm, kinda naughty
  (define-key key-translation-map (kbd "C-x 8 e") (kbd "🐘"))
  (define-key key-translation-map (kbd "C-x 8 p") (kbd "π"))
  (define-key key-translation-map (kbd "C-x 8 s") (kbd "🦑"))
  (define-key key-translation-map (kbd "C-x 8 o") (kbd "🐙"))
  (define-key key-translation-map (kbd "C-x 8 w") (kbd "🐳"))
  (define-key key-translation-map (kbd "C-x 8 W") (kbd "🐋"))
  (define-key key-translation-map (kbd "C-x 8 O") (kbd "Ω"))
  (define-key key-translation-map (kbd "C-x 8 #") (kbd "£"))
  (define-key key-translation-map (kbd "C-x 8 t") (kbd "✔"))
  (define-key key-translation-map (kbd "C-x 8 c") (kbd "✘"))
  (define-key key-translation-map (kbd "C-x 8 b") (kbd "⦿"))
  (define-key key-translation-map (kbd "C-x 8 2") (kbd "²"))
  (global-set-key (kbd "C-c i") (function info-other-window))
 #+END_SRC

* =Smartparens=
#+BEGIN_SRC emacs-lisp
(after! smartparens
  (show-smartparens-global-mode)

    ;; Navigation
  (define-key smartparens-mode-map (kbd "C-M-f") #'sp-forward-sexp)
  (define-key smartparens-mode-map (kbd "C-M-b") #'sp-backward-sexp)
  (define-key smartparens-mode-map (kbd "C-M-v") #'sp-backward-up-sexp)
  (define-key smartparens-mode-map (kbd "C-M-g") #'sp-up-sexp)
  (define-key smartparens-mode-map (kbd "C-M-c") #'sp-down-sexp)
  (define-key smartparens-mode-map (kbd "C-M-d") #'sp-backward-down-sexp)
  (define-key smartparens-mode-map (kbd "C-M-a") #'sp-beginning-of-sexp)
  (define-key smartparens-mode-map (kbd "C-M-e") #'sp-end-of-sexp)
  (define-key smartparens-mode-map (kbd "C-M-n") #'sp-next-sexp)
  (define-key smartparens-mode-map (kbd "C-M-p") #'sp-previous-sexp)

  ;; (define-key smartparens-mode-map (kbd "C-M-q") #'sp-backward-up-sexp)
  ;; (define-key smartparens-mode-map (kbd "C-M-`") #'beginning-of-defun)

  ;; Transpose
  (define-key smartparens-mode-map (kbd "C-M-t") 'sp-transpose-sexp)

  ;; Mark/kill/copy
  (global-set-key [remap mark-sexp] #'sp-mark-sexp)
  (define-key smartparens-mode-map (kbd "C-M-k") #'sp-kill-sexp)
  (define-key smartparens-mode-map (kbd "C-M-w") #'sp-copy-sexp)
  (define-key smartparens-mode-map (kbd "C-M-2") #'sp-mark-sexp)

  ;; Unwrap and rewrap
  (define-key smartparens-mode-map (kbd "C-M-u") #'sp-splice-sexp)
  (define-key smartparens-mode-map (kbd "C-M-r") #'sp-rewrap-sexp)

  (define-key smartparens-mode-map (kbd "M-<delete>") #'sp-unwrap-sexp)
  (define-key smartparens-mode-map (kbd "M-<backspace>") #'sp-backward-unwrap-sexp)

  ;; Slurp/barf
  (define-key smartparens-mode-map (kbd "<s-right>") #'sp-forward-slurp-sexp)
  (define-key smartparens-mode-map (kbd "<C-s-right>") #'sp-forward-barf-sexp)
  (define-key smartparens-mode-map (kbd "<s-left>") #'sp-backward-slurp-sexp)
  (define-key smartparens-mode-map (kbd "<C-s-left>") #'sp-backward-barf-sexp)

  ;; Selecting functions
  (define-key smartparens-mode-map (kbd "C-M-z") 'beginning-of-defun)
  (define-key smartparens-mode-map (kbd "C-M-x") 'end-of-defun)
  (define-key smartparens-mode-map (kbd "C-M-SPC") 'mark-defun)

  ;; Reintroduce for org-mode
  ;; (define-key smartparens-mode-map (kbd "C-M-<backspace>") #'sp-splice-sexp-killing-backward)
  ;; (define-key smartparens-mode-map (kbd "C-S-<backspace>") #'sp-splice-sexp-killing-around)
  ;; Indent
  ;; (define-key smartparens-mode-map (kbd "C-M-<tab>") #'sp-indent-defun)
  )
 #+END_SRC
* Open =magit= by default when opening project
#+BEGIN_SRC emacs-lisp
 (setq projectile-switch-project-action 'projectile-vc)
 #+END_SRC
* Multiple cursors

#+begin_src emacs-lisp
(use-package! multiple-cursors
  :bind
  ("C->" . mc/mark-next-like-this)
  ("C-<" . mc/mark-previous-like-this)
  ("C-)" . mc/mark-next-lines)
  ("C-(" . mc/mark-previous-lines))
#+end_src
* Minor Functions
** =my/read-string-from-file=
#+BEGIN_SRC emacs-lisp
  (defun my/read-string-from-file (filePath)
    "Return filePath's file content."
    (with-temp-buffer
      (insert-file-contents filePath)
      (buffer-string)))
 #+END_SRC
** =my/copy-line=
#+BEGIN_SRC emacs-lisp
  (defun my/copy-line ()
    "Copies the current line of the cursor
       Returns the current line as a string"
    (interactive)
    (buffer-substring (line-beginning-position) (line-end-position)))
 #+END_SRC
** DOWN =my/copy-line-save-position=
#+BEGIN_SRC emacs-lisp
  ;; (defun my/copy-line-save-position ()
  ;;   (interactive)
  ;;   (save-excursion ;;save the cursor position
  ;;     (kill-new            ;;kill the following
  ;;      (buffer-substring ;;from begginin of line to end of line
  ;;       (point-at-bol)
  ;;       (point-at-eol)))))
  ;; (global-set-key (kbd "C-c w l") (function my/copy-line-save-position))
#+END_SRC
** =my/drop-duplicates-in-list=
#+BEGIN_SRC emacs-lisp
  (defun my/drop-duplicates-in-list (list)
    (let ((new-list nil))
      (while list
        (when (and (car list) (not (member (car list) new-list)))
          (setq new-list (cons (car list) new-list)))
        (setq list (cdr list)))
      (nreverse new-list)))
 #+END_SRC
** =my/strings/recursive-count=                                      :regex:
#+BEGIN_SRC emacs-lisp
  (defun my/strings/recursive-count (regex string start)
    "Count number of matches in string eggining from 'start' offset"
    (if (string-match regex string start)
        (+ 1 (my/strings/recursive-count regex string (match-end 0)))
      0))
 #+END_SRC
** =my/extract-string=
#+BEGIN_SRC emacs-lisp
  (defun my/extract-string (regexp index string)
    "Extract a particular part of a regexp from the chosen string
    -------------------------------------------------------------------
    regexp     regular expression with individual arguments in \\(\\)
    index         index match to extract
    string        string to extract from
    "
    (string-match regexp string)
    (match-string index string))
 #+END_SRC
** =my/figlet=
#+BEGIN_SRC emacs-lisp
  (defun my/figlet (string-to-convert)
    "Converts 'string-to-convert' to ascii art and inserts it into buffer

      string-to-convert:	string to turn to art
      "
    (interactive "sString to make into art: ")
    (let* ((ascii-art (shell-command-to-string (concat "figlet -k" " " string-to-convert))))
      (setq ascii-art (replace-regexp-in-string "^"
                                                comment-start
                                                ascii-art))
      (insert ascii-art)
      ))
 #+END_SRC
** =my/file-name-from-line=
#+BEGIN_SRC emacs-lisp
  (defun my/file-name-from-line (prefix suffix)
    "Copies the current line and elinates all spaces"
    (interactive)
    (let* (
           (file-name (my/copy-line))
           (file-name (replace-regexp-in-string "^\s*" "" file-name))
           (file-name (downcase file-name))
           (file-name (replace-regexp-in-string " " "_" file-name))
           (file-name (concat prefix file-name suffix)))
      (message file-name)))
 #+END_SRC
** =my/generate-filename-from-line=
#+BEGIN_SRC emacs-lisp
  (defun my/generate-filename-from-line ()
    "Reads in the current line and generates a valid filename with an underscore"
    (let* (;reads in current line
           (file-name (my/copy-line)))
      ;; Trim leading whitespaces -> downcase -> replace spaces with underscore
      (replace-regexp-in-string " " "_" (downcase (replace-regexp-in-string "^\s*" "" file-name)))))
 #+END_SRC
** =my/rename-file-and-buffer=
#+BEGIN_SRC emacs-lisp
  (defun my/rename-file-and-buffer ()
    "Rename the current buffer and file it is visiting."
    (interactive)
    (let ((filename (buffer-file-name)))
      (if (not (and filename (file-exists-p filename)))
          (message "Buffer is not visiting a file!")
        (let ((new-name (read-file-name "New name: " filename)))
          (cond
           ((vc-backend filename) (vc-rename-file filename new-name))
           (t
            (rename-file filename new-name t)
            (set-visited-file-name new-name t t)))))))
 #+END_SRC
** =my/write-list-into-current-buffer=
#+BEGIN_SRC emacs-lisp
  (defun my/write-list-into-current-buffer (list-to-write)
    "Inserts elements of a simple list 1-by-1 into the current file"
    (while list-to-write
      (insert (format "%s\n" (car list-to-write)))
      (setq list-to-write (cdr list-to-write))))
 #+END_SRC
