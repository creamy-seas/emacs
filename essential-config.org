#+TITLE: First file to load
#+STARTUP: overview
#+PROPERTY: header-args :tangle yes

* IDO mode
#+begin_src emacs-lisp
(ido-vertical-mode 1)
(setq ido-vertical-define-keys 'C-n-and-C-p-only)
#+end_src

* Mac keymap
Mapping of mac right keyboard to meta

#+BEGIN_SRC emacs-lisp
(setq ns-right-option-modifier 'meta
      mac-right-option-modifier 'meta)
#+END_SRC

* Kill current buffer
Always kill the current buffer - for some reason it is not the default

#+BEGIN_SRC emacs-lisp
(defun my/kill-curr-buffer ()
  (interactive)
  (kill-buffer (current-buffer)))
(global-set-key (kbd "C-x k") 'my/kill-curr-buffer)
#+END_SRC

* Line numbers
#+BEGIN_SRC emacs-lisp
;; This determines the style of line numbers in effect. If set to `nil', line
;; numbers are disabled. For relative line numbers, set this to `relative'.
(setq display-line-numbers-type t)
(setq display-line-numbers-type nil)
#+END_SRC

* Identification
- GPG configuration and email
#+BEGIN_SRC emacs-lisp
(setq user-full-name "Ilya Antonov")
(setq user-mail-address "ilya.antonov24@ntlworld.com")
 #+END_SRC

* Compiling of literate configuration
Whenever an org file specifying configuration is saved
1. Tangle it (extract out all of the Emacs-lisp code blocks)
2. Compile it (=.el= -> =.elc=)
3. Reload doom

#+BEGIN_SRC emacs-lisp
  (defun my/config-file-tangle ()
    "Should be run after saving every file - check if it is a config file in the doom directory and tangle if yes"
    (if (and
         (equal (file-name-extension (buffer-file-name)) "org")
         (not (equal (file-name-base (buffer-file-name)) "cheatsheet"))
         (equal (file-name-directory (buffer-file-name)) (expand-file-name doom-private-dir)))
          ;; Tangle the file and bytecompile it
        (let ((el-file-name (replace-regexp-in-string "\\.org" ".el" buffer-file-name)))
            (org-babel-tangle-file buffer-file-name el-file-name "emacs-lisp")
            (byte-compile-file el-file-name t)
            ;;(doom/reload)
            (message (concat "î¤¦ Compiled and loaded " el-file-name)))))
  (add-hook 'after-save-hook 'my/config-file-tangle)
 #+END_SRC
* My keymap

#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/keymap)
  (global-set-key (kbd "C-z") 'my/keymap)
  (global-set-key (kbd "C-\\") 'my/keymap)
 #+END_SRC

* Saving hooks

#+BEGIN_SRC emacs-lisp
(add-hook 'before-save-hook #'whitespace-cleanup)
(add-hook 'before-save-hook 'delete-trailing-whitespace)
(setq require-final-newline    t)
(setq next-line-add-newlines nil)
 #+END_SRC

* Overwrite selected text when typing
#+BEGIN_SRC emacs-lisp
(delete-selection-mode t)
 #+END_SRC

* PACKAGE Hungry delete
Hungry delete deletes all white space between cursor and the next character
#+BEGIN_SRC emacs-lisp
  (use-package! hungry-delete
    :config
    (global-hungry-delete-mode))
#+END_SRC

* PACKAGE Searching with Swiper =C-s=

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-s") (function counsel-grep-or-swiper))
(setq counsel-grep-base-command
      "rg -i -M 120 --no-heading --line-number --color never %s %s")

(setq counsel-grep-use-swiper-p
      ;; When this functions returns non-nil, call 'swiper', else 'counsel-grep-base-command'
      (lambda ()
        (or
         ;; If buffer is small enough
         (<= (buffer-size) (/ counsel-grep-swiper-limit (if (eq major-mode 'org-mode) 4 1)))
         (string-match "\\.gpg$" (file-name-nondirectory (buffer-file-name))))))




#+END_SRC

* Browsing configuration files =C-c f i=

#+begin_src emacs-lisp
(defun my/config-file-open ()
  "Browser config files in `doom-private-dir'."
  (interactive)
  (let ((file-list
         ;; Remove files that are not org files and not one of the default doom files
         (cl-remove-if-not
          (lambda (x)
            (or (equal "org" (file-name-extension x))
                (string-match "^\\(config\\|custom\\|packages\\|init\\).el$" x)))
          (directory-files doom-private-dir))))
    (find-file (concat doom-private-dir (ido-completing-read "Config file: " file-list)))))

(global-set-key (kbd "C-c f i") (function my/config-file-open))
#+end_src

* Yasnippet
Autocompletion by typing in first part of word and tabbing to insert a template
- yasnippet is the framework
- yasnippet-snippets is the official collection of snippets

#+BEGIN_SRC emacs-lisp
(use-package! yasnippet-snippets
  :config
  (setq yas-snippet-dirs (list
                          (concat doom-private-dir "my-snippets")
                          'yasnippet-snippets-dir))
  (yas-reload-all))
(yas-global-mode)
 #+END_SRC

* Auto yasnippets

Quickly create disposable yasnippets with =~=
#+BEGIN_SRC emacs-lisp
  (use-package! auto-yasnippet
    :config
    (define-key my/keymap (kbd "s") (function aya-create))
    (define-key my/keymap (kbd "y") (function aya-expand)))
 #+END_SRC

* Spellchecking

If you want to check specific buffer with different language, add the following to top of buffer
#+begin_example
-*- ispell-dictionary: "english" -*-
#+end_example

#+BEGIN_SRC emacs-lisp
(setq ispell-personal-dictionary "/Users/CCCP/.aspell.en.pws")
;;(global-set-key (kbd "C-x C-b") (function ispell-buffer))
;;(global-set-key (kbd "C-x C-B") (function ispell-word))
 #+END_SRC

** External setup
#+BEGIN_SRC emacs-lisp
  (setq ispell-program-name "/usr/local/bin/aspell")
  (setq ispell-dictionary "en_GB")
 #+END_SRC

** Region skips
#+BEGIN_SRC emacs-lisp
(setq ispell-tex-skip-alists
      (list
       (append
        (car ispell-tex-skip-alists)
        '(("\\\\eqref"   ispell-tex-arg-end 1)
          ("\\\\label"   ispell-tex-arg-end 1)
          ("\\\\inkfig"   ispell-tex-arg-end 2)
          ("\\\\gls"   ispell-tex-arg-end 1)
          ("\\\\glspl"   ispell-tex-arg-end 1)
          ("\\\\begin{tabular}"   ispell-tex-arg-end 1) ;; skip column specification
          ("[^\\]\\$" . "[^\\]\\$")
          ))
       (cadr ispell-tex-skip-alists)))
(add-to-list 'ispell-skip-region-alist '("\\\\begin{equation}". "\\\\end{equation}"))
 #+END_SRC

** DOWN Hydra
#+BEGIN_SRC emacs-lisp
  ;; (defun my/switch-dictionary ()
  ;;   "Switch dictionary"
  ;;   (interactive)
  ;;   (if (string-equal ispell-dictionary "en_GB")
  ;;       (progn
  ;;         (ispell-change-dictionary "ru")
  ;;         (message "Changed to Russian ï¶"))
  ;;     (progn
  ;;       (ispell-change-dictionary "en_GB")
  ;;       (message "Switched to English"))))
  ;; (define-key my/keymap (kbd "r") 'my/switch-dictionary)

  ;; (defhydra hydra-flyspell (
  ;;                           :color red
  ;;                           :hint nil
  ;;                           )
  ;;   "
  ;;   ------------------------------------------------------------------------------------------
  ;;   _n_: Go to next error
  ;;   _a_: Autocorrect
  ;;   _c_: Correct word
  ;;   _t_: Flyspell mode
  ;;   _b_: Check the current buffer
  ;;   "
  ;;   ("n" flyspell-goto-next-error)
  ;;   ("a" flyspell-auto-correct-word)
  ;;   ("t" flyspell-mode)
  ;;   ("c" ispell-word)
  ;;   ("b" ispell-buffer)
  ;;   ;;("d" ispell-change-dictionary)
  ;;   ;;("t" my/switch-dictionary)
  ;;   ("q"   nil "cancel" :color blue))

  ;; (define-key my/keymap (kbd "w") (function hydra-flyspell/body))
  ;; (define-key my/keymap (kbd "B") (function ispell-buffer))
 #+END_SRC
** DOWN Set dictionaries
#+BEGIN_SRC emacs-lisp
  ;; Save to user dictionary
  ;;(setq ispell-silently-savep t)
  ;; (setq ispell-personal-dictionary "/Users/CCCP/.aspell.en.prepl"
  ;; (my/config-file-path-evaluate "dictionaries/aspell.en.pws")
  ;; )
 #+END_SRC
* Company
- Completion. With a dropdown box. Metal.
- Name stands for compLETEanything

| =company-backends= | Lists backends that are used to return candidates |

#+BEGIN_SRC emacs-lisp
(after! company
  (setq company-tooltip-align-annotations t)
                                        ;set time before company popup shows up
  (setq company-idle-delay 0.2)
                                        ;;when autocompletion kicks in
  (setq company-minimum-prefix-length 4))
 #+END_SRC

* Undo Tree     =M-/=
Spawns a tree of all the undos that you have ever made
#+BEGIN_SRC emacs-lisp
(use-package! undo-tree
  :config
  (global-undo-tree-mode)
  (setq undo-tree-visualizer-timestamps t)
  (setq undo-tree-visualizer-diff t)
  (global-set-key (kbd "M-/") 'undo-tree-visualize)
  )
#+END_SRC

* Tabs
Tabs are bloat. Read about them [[http://www.xemacs.org/Links/tutorials_1.html][here]]
** Change display of tabs
#+BEGIN_SRC emacs-lisp
  (setq-default tab-width 4)
 #+END_SRC
** Prevent using tabs for indent
#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
 #+END_SRC
* iedit =C-:=
Mark and edit all copies of the marked region simultaneously.
#+BEGIN_SRC emacs-lisp
(use-package! iedit
  :bind ("C-:" . iedit-mode))
 #+END_SRC
* Automatic file reload
Any changes of a file, will be automatically reloaded
#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode 1)
(setq load-prefer-newer t)
 #+END_SRC
* Russian keymap
#+BEGIN_SRC emacs-lisp
  (use-package! reverse-im
    :config
    (reverse-im-activate "russian-computer"))
 #+END_SRC
* Symbols mapping
#+BEGIN_SRC emacs-lisp
  (define-key key-translation-map (kbd "C-x 8 h") (kbd "å")) ; naughty
  (define-key key-translation-map (kbd "C-x 8 C") (kbd "â˜­")) ; erm, kinda naughty
  (define-key key-translation-map (kbd "C-x 8 e") (kbd "ðŸ˜"))
  (define-key key-translation-map (kbd "C-x 8 p") (kbd "Ï€"))
  (define-key key-translation-map (kbd "C-x 8 s") (kbd "ðŸ¦‘"))
  (define-key key-translation-map (kbd "C-x 8 o") (kbd "ðŸ™"))
  (define-key key-translation-map (kbd "C-x 8 w") (kbd "ðŸ³"))
  (define-key key-translation-map (kbd "C-x 8 W") (kbd "ðŸ‹"))
  (define-key key-translation-map (kbd "C-x 8 O") (kbd "Î©"))
  (define-key key-translation-map (kbd "C-x 8 #") (kbd "Â£"))
  (define-key key-translation-map (kbd "C-x 8 t") (kbd "âœ”"))
  (define-key key-translation-map (kbd "C-x 8 c") (kbd "âœ˜"))
  (define-key key-translation-map (kbd "C-x 8 b") (kbd "â¦¿"))
  (define-key key-translation-map (kbd "C-x 8 2") (kbd "Â²"))
  (global-set-key (kbd "C-c i") (function info-other-window))
 #+END_SRC

* Smartparens
#+BEGIN_SRC emacs-lisp
(after! smartparens
  (show-smartparens-global-mode)

    ;; Navigation
  (define-key smartparens-mode-map (kbd "C-M-f") #'sp-forward-sexp)
  (define-key smartparens-mode-map (kbd "C-M-b") #'sp-backward-sexp)
  (define-key smartparens-mode-map (kbd "C-M-v") #'sp-backward-up-sexp)
  (define-key smartparens-mode-map (kbd "C-M-g") #'sp-up-sexp)
  (define-key smartparens-mode-map (kbd "C-M-c") #'sp-down-sexp)
  (define-key smartparens-mode-map (kbd "C-M-d") #'sp-backward-down-sexp)
  (define-key smartparens-mode-map (kbd "C-M-a") #'sp-beginning-of-sexp)
  (define-key smartparens-mode-map (kbd "C-M-e") #'sp-end-of-sexp)
  (define-key smartparens-mode-map (kbd "C-M-n") #'sp-next-sexp)
  (define-key smartparens-mode-map (kbd "C-M-p") #'sp-previous-sexp)

  ;; (define-key smartparens-mode-map (kbd "C-M-q") #'sp-backward-up-sexp)
  ;; (define-key smartparens-mode-map (kbd "C-M-`") #'beginning-of-defun)

  ;; Transpose
  (define-key smartparens-mode-map (kbd "C-M-t") 'sp-transpose-sexp)

  ;; Mark/kill/copy
  (global-set-key [remap mark-sexp] #'sp-mark-sexp)
  (define-key smartparens-mode-map (kbd "C-M-k") #'sp-kill-sexp)
  (define-key smartparens-mode-map (kbd "C-M-w") #'sp-copy-sexp)
  (define-key smartparens-mode-map (kbd "C-M-2") #'sp-mark-sexp)

  ;; Unwrap and rewrap
  (define-key smartparens-mode-map (kbd "C-M-u") #'sp-splice-sexp)
  (define-key smartparens-mode-map (kbd "C-M-r") #'sp-rewrap-sexp)

  (define-key smartparens-mode-map (kbd "M-<delete>") #'sp-unwrap-sexp)
  (define-key smartparens-mode-map (kbd "M-<backspace>") #'sp-backward-unwrap-sexp)

  ;; Slurp/barf
  (define-key smartparens-mode-map (kbd "<s-right>") #'sp-forward-slurp-sexp)
  (define-key smartparens-mode-map (kbd "<C-s-right>") #'sp-forward-barf-sexp)
  (define-key smartparens-mode-map (kbd "<s-left>") #'sp-backward-slurp-sexp)
  (define-key smartparens-mode-map (kbd "<C-s-left>") #'sp-backward-barf-sexp)

  ;; Selecting functions
  (define-key smartparens-mode-map (kbd "C-M-z") 'beginning-of-defun)
  (define-key smartparens-mode-map (kbd "C-M-x") 'end-of-defun)
  (define-key smartparens-mode-map (kbd "C-M-SPC") 'mark-defun)

  ;; Reintroduce for org-mode
  ;; (define-key smartparens-mode-map (kbd "C-M-<backspace>") #'sp-splice-sexp-killing-backward)
  ;; (define-key smartparens-mode-map (kbd "C-S-<backspace>") #'sp-splice-sexp-killing-around)
  ;; Indent
  ;; (define-key smartparens-mode-map (kbd "C-M-<tab>") #'sp-indent-defun)
  )
 #+END_SRC
* Open magit by default when opening project
#+BEGIN_SRC emacs-lisp
 (setq projectile-switch-project-action 'projectile-vc)
 #+END_SRC
* Multiple cursors

#+begin_src emacs-lisp
(use-package! multiple-cursors
  :bind
  ("C->" . mc/mark-next-like-this)
  ("C-<" . mc/mark-previous-like-this)
  ("C-)" . mc/mark-next-lines)
  ("C-(" . mc/mark-previous-lines))
#+end_src
* Minor Functions
** =my/read-string-from-file=
#+BEGIN_SRC emacs-lisp
  (defun my/read-string-from-file (filePath)
    "Return filePath's file content."
    (with-temp-buffer
      (insert-file-contents filePath)
      (buffer-string)))
 #+END_SRC
** =my/copy-line=
#+BEGIN_SRC emacs-lisp
  (defun my/copy-line ()
    "Copies the current line of the cursor
       Returns the current line as a string"
    (interactive)
    (buffer-substring (line-beginning-position) (line-end-position)))
 #+END_SRC
** DOWN =my/copy-line-save-position=
#+BEGIN_SRC emacs-lisp
  ;; (defun my/copy-line-save-position ()
  ;;   (interactive)
  ;;   (save-excursion ;;save the cursor position
  ;;     (kill-new            ;;kill the following
  ;;      (buffer-substring ;;from begginin of line to end of line
  ;;       (point-at-bol)
  ;;       (point-at-eol)))))
  ;; (global-set-key (kbd "C-c w l") (function my/copy-line-save-position))
#+END_SRC
** =my/drop-duplicates-in-list=
#+BEGIN_SRC emacs-lisp
  (defun my/drop-duplicates-in-list (list)
    (let ((new-list nil))
      (while list
        (when (and (car list) (not (member (car list) new-list)))
          (setq new-list (cons (car list) new-list)))
        (setq list (cdr list)))
      (nreverse new-list)))
 #+END_SRC
** =my/strings/recursive-count=                                      :regex:
#+BEGIN_SRC emacs-lisp
  (defun my/strings/recursive-count (regex string start)
    "Count up total number of matches of regex in a string, beggining from 'start' offset"
    (if (string-match regex string start)
        (+ 1 (my/strings/recursive-count regex string (match-end 0)))
      0))
 #+END_SRC
** =my/extract-string=
#+BEGIN_SRC emacs-lisp
  (defun my/extract-string (regexp index string)
    "Extract a particular part of a regexp from the chosen string
    -------------------------------------------------------------------
    regexp     regular expression with individual arguments in \\(\\)
    index         index match to extract
    string        string to extract from
    "
    (string-match regexp string)
    (match-string index string))
 #+END_SRC
** =my/figlet=
#+BEGIN_SRC emacs-lisp
  (defun my/figlet (string-to-convert)
    "Converts 'string-to-convert' to ascii art and inserts it into buffer

      string-to-convert:	string to turn to art
      "
    (interactive "sString to make into art: ")
    (let* ((ascii-art (shell-command-to-string (concat "figlet -k" " " string-to-convert))))
      (setq ascii-art (replace-regexp-in-string "^"
                                                comment-start
                                                ascii-art))
      (insert ascii-art)
      ))
 #+END_SRC
** =my/file-name-from-line=
#+BEGIN_SRC emacs-lisp
  (defun my/file-name-from-line (prefix suffix)
    "Copies the current line and elinates all spaces"
    (interactive)
    (let* (
           (file-name (my/copy-line))
           (file-name (replace-regexp-in-string "^\s*" "" file-name))
           (file-name (downcase file-name))
           (file-name (replace-regexp-in-string " " "_" file-name))
           (file-name (concat prefix file-name suffix)))
      (message file-name)))
 #+END_SRC
** =my/generate-filename-from-line=
#+BEGIN_SRC emacs-lisp
  (defun my/generate-filename-from-line ()
    "Reads in the current line and generates a valid filename with an underscore"
    (let* (;reads in current line
           (file-name (my/copy-line)))
      ;; Trim leading whitespaces -> downcase -> replace spaces with underscore
      (replace-regexp-in-string " " "_" (downcase (replace-regexp-in-string "^\s*" "" file-name)))))
 #+END_SRC
** =my/rename-file-and-buffer=
#+BEGIN_SRC emacs-lisp
  (defun my/rename-file-and-buffer ()
    "Rename the current buffer and file it is visiting."
    (interactive)
    (let ((filename (buffer-file-name)))
      (if (not (and filename (file-exists-p filename)))
          (message "Buffer is not visiting a file!")
        (let ((new-name (read-file-name "New name: " filename)))
          (cond
           ((vc-backend filename) (vc-rename-file filename new-name))
           (t
            (rename-file filename new-name t)
            (set-visited-file-name new-name t t)))))))
 #+END_SRC
** =my/write-list-into-current-buffer=
#+BEGIN_SRC emacs-lisp
  (defun my/write-list-into-current-buffer (list-to-write)
    "Inserts elements of a simple list 1-by-1 into the current file"
    (while list-to-write
      (insert (format "%s\n" (car list-to-write)))
      (setq list-to-write (cdr list-to-write))))
 #+END_SRC
