#+TITLE: Navigation

* Open common buffers
#+begin_src emacs-lisp
(global-set-key (kbd "C-c f s") 'list-processes)
#+end_src

* Buffer name style
#+BEGIN_SRC emacs-lisp
  (setq uniquify-buffer-name-style 'post-forward)
 #+END_SRC
* Moving in subwords
#+BEGIN_SRC emacs-lisp
  (global-subword-mode 1)
#+END_SRC
* Projectile default load
#+begin_src emacs-lisp
(after! counsel-projectile
  (setcar counsel-projectile-switch-project-action 14))
#+end_src
* Open =magit= by default when opening project
#+BEGIN_SRC emacs-lisp
 (setq projectile-switch-project-action 'projectile-vc)
 #+END_SRC
* Window splitting

#+BEGIN_SRC emacs-lisp
(defun split-and-follow-horizontally ()
  (interactive)
  (split-window-below)
  (balance-windows)
  (other-window 1))
(global-set-key (kbd "C-x 2") 'split-and-follow-horizontally)

(defun split-and-follow-vertically ()
  (interactive)
  (split-window-right)
  (balance-windows)
  (other-window 1))
(global-set-key (kbd "C-x 3") 'split-and-follow-vertically)

(setq split-height-threshold 80)
(setq split-width-threshold 160)
#+END_SRC

* PACKAGE Eyebrowse multiple windows =s-a, s-s, s-d=

#+BEGIN_SRC emacs-lisp
(use-package! eyebrowse
  :config
  (eyebrowse-mode)
  (global-set-key (kbd "s-a") (function eyebrowse-switch-to-window-config-1))
  (global-set-key (kbd "s-s") (function eyebrowse-switch-to-window-config-2))
  (global-set-key (kbd "s-d") (function eyebrowse-switch-to-window-config-3))
  (global-set-key (kbd "s-f") (function eyebrowse-switch-to-window-config-4))
  (global-set-key (kbd "s-g") (function eyebrowse-switch-to-window-config-5))
  )
#+END_SRC
* PACKAGE =avy= =M-s=
The superior search method with highlighting of the leading characters.
#+BEGIN_SRC emacs-lisp
(use-package! avy
  :config
  (global-set-key (kbd "M-s") 'avy-goto-word-or-subword-1)
  (setq avy-background t)
  (setq avy-all-windows t))
#+END_SRC
* PACKAGE Searching with swiper =C-s=
#+BEGIN_SRC emacs-lisp
 (global-set-key (kbd "C-s") (function counsel-grep-or-swiper))
 (setq counsel-grep-base-command
       "rg -i -M 120 --no-heading --line-number --color never %s %s")

 (setq counsel-grep-use-swiper-p
       ;; When this functions returns non-nil, call 'swiper', else 'counsel-grep-base-command'
       (lambda ()
         (or
          ;; If buffer is small enough
          (<= (buffer-size) (/ counsel-grep-swiper-limit (if (eq major-mode 'org-mode) 4 1)))
          (string-match "\\.gpg$" (file-name-nondirectory (buffer-file-name))))))

#+END_SRC

* PACKAGE Window switching =s-o=
#+BEGIN_SRC emacs-lisp
(use-package! switch-window
  :config
  (global-set-key (kbd "s-o") 'switch-window))
#+END_SRC
* PACKAGE =Smartparens= =C-M-somekey=
#+BEGIN_SRC emacs-lisp
(after! smartparens
  (show-smartparens-global-mode)

    ;; Navigation
  (define-key smartparens-mode-map (kbd "C-M-f") #'sp-forward-sexp)
  (define-key smartparens-mode-map (kbd "C-M-b") #'sp-backward-sexp)
  (define-key smartparens-mode-map (kbd "C-M-v") #'sp-backward-up-sexp)
  (define-key smartparens-mode-map (kbd "C-M-g") #'sp-up-sexp)
  (define-key smartparens-mode-map (kbd "C-M-c") #'sp-down-sexp)
  (define-key smartparens-mode-map (kbd "C-M-d") #'sp-backward-down-sexp)
  (define-key smartparens-mode-map (kbd "C-M-a") #'sp-beginning-of-sexp)
  (define-key smartparens-mode-map (kbd "C-M-e") #'sp-end-of-sexp)
  (define-key smartparens-mode-map (kbd "C-M-n") #'sp-next-sexp)
  (define-key smartparens-mode-map (kbd "C-M-p") #'sp-previous-sexp)

  ;; (define-key smartparens-mode-map (kbd "C-M-q") #'sp-backward-up-sexp)
  ;; (define-key smartparens-mode-map (kbd "C-M-`") #'beginning-of-defun)

  ;; Transpose
  (define-key smartparens-mode-map (kbd "C-M-t") 'sp-transpose-sexp)

  ;; Mark/kill/copy
  (global-set-key [remap mark-sexp] #'sp-mark-sexp)
  (define-key smartparens-mode-map (kbd "C-M-k") #'sp-kill-sexp)
  (define-key smartparens-mode-map (kbd "C-M-w") #'sp-copy-sexp)
  (define-key smartparens-mode-map (kbd "C-M-2") #'sp-mark-sexp)

  ;; Unwrap and rewrap
  (define-key smartparens-mode-map (kbd "C-M-u") #'sp-splice-sexp)
  (define-key smartparens-mode-map (kbd "C-M-r") #'sp-rewrap-sexp)

  (define-key smartparens-mode-map (kbd "M-<delete>") #'sp-unwrap-sexp)
  (define-key smartparens-mode-map (kbd "M-<backspace>") #'sp-backward-unwrap-sexp)

  ;; Slurp/barf
  (define-key smartparens-mode-map (kbd "<s-right>") #'sp-forward-slurp-sexp)
  (define-key smartparens-mode-map (kbd "<C-s-right>") #'sp-forward-barf-sexp)
  (define-key smartparens-mode-map (kbd "<s-left>") #'sp-backward-slurp-sexp)
  (define-key smartparens-mode-map (kbd "<C-s-left>") #'sp-backward-barf-sexp)

  ;; Selecting functions
  (define-key smartparens-mode-map (kbd "C-M-z") 'beginning-of-defun)
  (define-key smartparens-mode-map (kbd "C-M-x") 'end-of-defun)
  (define-key smartparens-mode-map (kbd "C-M-SPC") 'mark-defun)

  ;; Reintroduce for org-mode
  ;; (define-key smartparens-mode-map (kbd "C-M-<backspace>") #'sp-splice-sexp-killing-backward)
  ;; (define-key smartparens-mode-map (kbd "C-S-<backspace>") #'sp-splice-sexp-killing-around)
  ;; Indent
  ;; (define-key smartparens-mode-map (kbd "C-M-<tab>") #'sp-indent-defun)
  )
 #+END_SRC
* PACKAGE Multiple cursors =C->= and =C-)=
#+begin_src emacs-lisp
(use-package! multiple-cursors
  :bind
  ("C->" . mc/mark-next-like-this)
  ("C-<" . mc/mark-previous-like-this)
  ("C-)" . mc/mark-next-lines)
  ("C-(" . mc/mark-previous-lines))
#+end_src
