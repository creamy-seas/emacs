
        
        
        
        
        
        <p><em>TL;DR Chrome team breaks web to make Chrome perform better.</em></p>

<p>There’s a widely-used piece of DOM API called <code class="highlighter-rouge">addEventListener</code>. Almost every web site or web app that does anything dynamic with JS probably depends on this method in some way.</p>

<p>Up until 2016 the convention was that you just pass an event type, a callback and an optional “useCapture” boolean flag:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>target.addEventListener(type, listener[, useCapture]);
</code></pre></div></div>

<p>Then Google <a href="https://github.com/whatwg/dom/pull/82">came along</a> and decided that this API is not extensible enough (which is true). What if one wanted more options? Surely, there must be a map of options, not just a single positional boolean argument. To which, again, I can’t agree more. So they added a second form:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>addEventListener(type, listener[, useCapture]);
addEventListener(type, listener[, options]);
</code></pre></div></div>

<p>Which means you can’t practically use the new form without feature detection. At all. Never ever. Old browsers can’t be made to understand <code class="highlighter-rouge">options</code> form. Period.</p>

<p>But that’s fine. That’s all right. That’s why we have feature detection.</p>

<h2 id="dom-apis-arent-meant-to-be-used">DOM APIs aren’t meant to be used</h2>

<p>Ok, so there must be some sort of feature detection API accompanying this change, right? Well, if you thought so, you clearly have never worked with web APIs. Even though web developers are <em>supposed</em> to <em>always</em> use feature detection, they’re also supposed to rely on a complex, brittle and accidental effects to check for it.</p>

<p>This is the code <a href="https://github.com/WICG/EventListenerOptions/issues/16">you’re supposed to be using</a>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var supportsPassive = false;
try {
  var opts = Object.defineProperty({}, 'passive', {
    get: function() {
      supportsPassive = true;
    }
  });
  window.addEventListener("test", null, opts);
} catch (e) {}
</code></pre></div></div>

<p>Basically, you’re constructing a special object with a side-effect-producing getter and hope for the browser to access it when you install a fake event listener. Surely, what could go wrong?</p>

<p>To be fair, there’s <a href="https://github.com/whatwg/dom/issues/491">an open discussion</a> for adding better feature detection around this. But the timing is as messy as the API itself. If feature detection will ever be implemented, we’d have three browser classes:</p>

<ul>
  <li>the ones that don’t support <code class="highlighter-rouge">options</code> at all,</li>
  <li>the ones that do support it but don’t support feature detection for it (so you’ll have to resort to the getter+fake event hack anyway),</li>
  <li>and the ones that support both feature detection and the API.</li>
</ul>

<p>Think about it: a feature detection API that itself needs to be detected <nobr>¯\_(ツ)_/¯</nobr>.</p>

<h2 id="making-chrome-fast">Making Chrome fast</h2>

<p>But that’s not the end of the story. Chrome team proposed the API change to add <code class="highlighter-rouge">passive</code> option because it allowed them to speed up scrolling on mobile websites.</p>

<p>The gist of it: if you mark <code class="highlighter-rouge">onscroll</code>/<code class="highlighter-rouge">ontouch</code> event listener as <code class="highlighter-rouge">passive</code>, Mobile Google can scroll your page faster (let’s not go into details, but that’s how things <em>are</em>). Old websites continue to work (slow, as before), and new websites have <em>an option</em> to be made faster at the cost of an additional feature check and one more option. It’s a win-win, right?</p>

<p>Turned out, Google wasn’t concerned about your websites at all. It was more concerned about its own product performance, Google Chrome Mobile. That’s why on February 1, 2017, they made all top-level event listeners passive by default. They call it “<a href="https://developers.google.com/web/updates/2017/01/scrolling-intervention">an intervention</a>”.</p>

<p>Now, this is a terrible thing to do. It’s very, very, very bad. Basically, Chrome broke half of user websites, the ones that were relying on touch/scroll events being cancellable, at the benefit of winning some performance for websites that were not yet aware of this optional optimization.</p>

<p>This was <em>not</em> backward compatible change by any means. All websites and web apps that did any sort of draggable UI (sliders, maps, reorderable lists, even slide-in panels) were <em>affected</em> and essentially <em>broken</em> by this change.</p>

<p>Yet, if things become faster, they can always praise Mobile Chrome for the improvement. And if something breaks, people would probably blame website anyways. RByers (a Google Team engineer who advocated for the intervention) <a href="https://github.com/WICG/interventions/issues/18#issuecomment-309058348">commented on Jun 16</a>:</p>

<blockquote>
  <p>Our data suggests we made the right trade-off for the web platform as a whole and for Chrome as a product. I understand that your perspective is the opposite and I’m sorry about that - I really wish there was a way to make everyone happy, that’s just not reality.</p>
</blockquote>

<p>Also, notice how harsh timeline on this update was. The <code class="highlighter-rouge">passive</code> option was released on June 1, 2016 (Chrome 51). Passive made default was out on February 1, 2017 (Chrome 56). That’s just 8 months! They couldn’t even agree on feature detection API in that time! Before June 2016 you didn’t even have an API for marking listeners passive! And just 8 months later your app is already silently broken and punished for not using new API that others browsers barely started to roll out!</p>

<h2 id="excerpts-from-intervention-discussion">Excerpts from intervention discussion</h2>

<p>RByers <a href="https://github.com/WICG/interventions/issues/18#issuecomment-249916777">commented on Sep 27, 2016</a>:</p>

<blockquote>
  <p>Of course we’d need some transition path over many years to avoid breaking the web too badly in order to get there.</p>
</blockquote>

<p>RByers <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=639227#c27">commented on Feb 9</a>:</p>

<blockquote>
  <p>I’m deeply sorry for the frustration this has caused you. We’ve long tried the “opt-in” approach but have learned that on average developers don’t make the effort to opt-in to better performance.</p>
</blockquote>

<p>RByers <a href="https://github.com/WICG/interventions/issues/18#issuecomment-250315841">commented on Sep 29, 2016</a>:</p>

<blockquote>
  <p>Given the huge positive response <a href="https://www.youtube.com/watch?v=NPM6172J22g">that video</a> has gotten from users, we’re willing to accept a little bit of hacks / compat pain here.</p>
</blockquote>

<p>mixonic <a href="https://github.com/WICG/interventions/issues/18#issuecomment-279194353">commented on Feb 12</a>:</p>

<blockquote>
  <p>The video in question as 14k views and 36 “thumbs up”. I really, really hope this isn’t being used to make a decision about whether this intervention is appropriate.</p>
</blockquote>

<p>RByers <a href="https://github.com/WICG/interventions/issues/18#issuecomment-280532958">commented on Feb 17</a>:</p>

<blockquote>
  <p>We really don’t have more than anecdote (and our metrics) on the “support” side, and no precise way to quantify the breakage. I’d love to have a more quantifiable way to make these sorts of trade offs.</p>
</blockquote>

<p>RByers <a href="https://github.com/WICG/interventions/issues/18#issuecomment-279163417">commented on Feb 11</a>:</p>

<blockquote>
  <p>So far we’ve gotten a ton of feedback that users care about this.</p>
</blockquote>

<p>RByers linked to <a href="https://twitter.com/RickByers/status/719736672523407360">this tweet</a> with exactly 6 responses:</p>

<blockquote>
  <p><a href="https://twitter.com/adslaton/status/726094587056541699">adslaton</a>: thank you for the demo against our site. We will take a look at what you have documented and apply updates.</p>
</blockquote>

<blockquote>
  <p><a href="https://twitter.com/adamdbradley/status/719739381704040448">adamdbradley</a>: how did you do that test to see the differences?</p>
</blockquote>

<blockquote>
  <p><a href="https://twitter.com/jordwalke/status/720073223430217729">jordwalke</a>: I strongly, but super-respectfully suggest against this. It masks serious issues. I do not believe this is how the web wins.</p>
</blockquote>

<blockquote>
  <p><a href="https://twitter.com/rickbiastwit/status/832399971026505729">rickbiastwit</a>: and it’s not cool to break tons of drag/drop, scroll/zoom browser default behaviour prevention only to achieve nearly nothing</p>
</blockquote>

<blockquote>
  <p><a href="https://twitter.com/rickbiastwit/status/832399551847804928">rickbiastwit</a>: chrome scroll intervention demo is definitely misleading. I tried on top end devices, no perceivable difference, enabled or not.</p>
</blockquote>

<p>If you call it “a ton of positive feedback”, well, khm, you definitely see a reality in a different light.</p>

<h2 id="a-moral">A moral</h2>

<ul>
  <li>Web APIs aren’t pretty.</li>
  <li>There’s no “clean” way of using DOM APIs. Even freshly designed, freshly released features <em>require</em> you to rely on hacks for feature detection.</li>
  <li>Libraries wouldn’t simply “abstract away” all the unpleasant details of the underlying experience. E.g. React still <a href="https://github.com/facebook/react/issues/6436">has no way</a> to force event listeners not being passive.</li>
  <li>Making code work in older browsers is an easy task because older browsers do not change. Once hacks are implemented for them, they’ll continue to work forever.</li>
  <li>Code that works for you right now might stop working in <em>future</em> browsers. Constant effort is required maintaining your code against changes browser vendors drop on you.</li>
  <li>Breaking changes might happen pretty fast. Current version of Chrome is 62. Your code might being broken by the time Chrome 67 arrives. It almost certainly wouldn’t work in Chrome 100.</li>
  <li>Browser vendors have their own agenda. It mostly includes making their browsers look fast, sometimes at the cost of your websites become broken.</li>
</ul>

<p>RByers <a href="https://github.com/WICG/interventions/issues/18#issuecomment-278658295">commented on Feb 9</a>:</p>

<blockquote>
  <p>But in Chrome we’re fundamentally unwilling to allow the mobile web to continue to die from performance bankruptcy. Other browsers are less aggressive, and people who prefer to be more conservative (preferring maximal compatibility over being part of moving the web forward aggressively) should prefer to use a more conservative browser.</p>
</blockquote>

<p>As a user, I certainly do not care about “being part of moving the web forward aggressively”. Why should I? I like my stuff working, not broken. Nobody ever wants it the other way around.</p>

      